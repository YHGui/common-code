# Fork/Join框架
### 概述
根据之前的学习，开发并发应用程序有两个方法：
1. 创建Runnable对象，然后创建对应的Thread对象来控制程序中这些线程的创建、执行以及线程的状态；
2. 引入了执行器(Executor Framework)，将任务的创建和执行进行了分离，通过这个框架，只需要实现Runnable接口
的对象和使用Executor对象，然后将Runnable对象发送给执行器，执行器再负责运行这些任务所需要的线程，包括
线程的创建，线程的管理以及线程的结束。

Java7又更进了一步，包括了ExecutorService接口的另一种实现，用来解决特殊类型的问题，就是**Fork/Join**
框架，也称分解/合并框架。

Fork/Join框架是用来解决能够通过分治技术将问题拆分成小任务的问题。在一个任务中，先检查将要解决的问题的
大小，如果大于一个设定的大小，就将问题拆分成可以通过框架执行的小任务；如果问题大小比设定的大小要写，
就可以直接在任务里解决这个问题，然后，根据需要返回任务的结果。

这个框架主要有两个操作：
1. 分解(Fork)：当需要将一个任务拆分成更小的多个任务时，在框架中执行这些任务；
2. 合并(Join)：当一个主任务等待其创建的多个子任务的完成执行。

Fork/Join和Executor主要的区别在于工作窃取算法(Work-Stealing Algorithm)。与执行器框架不同，使用Join
操作让一个主任务等待它所创建的子任务的完成，执行这个任务的线程称之为工作者线程(Worker Thread)。工作者
线程寻找其他未被执行的任务，然后开始执行。通过这种方式，提升应用程序的性能。

有如下限制：
1. 任务只能使用fork()和join()操作当作同步机制。
2. 任务不能执行I/O操作
3. 任务不能抛出checked exception，必须在代码里处理掉。

Fork/Join框架核心：
1. ForkJoinPool：这个类实现了ExecutorService接口和工作窃取算法。管理工作者线程，并提供任务的状态
信息，以及任务的执行信息。
2. ForkJoinTask：这个类是一个将在ForkJoinPool中执行任务的基类。

Fork/Join框架提供了一个在任务里执行fork()和join()操作的机制和控制任务状态的方法。通常，为了实现
Fork/Join任务，需要实现一个以下两个类之一的子类：
1. RecursiveAction：用于任务没有返回结果的场景；
2. RecursiveTask：用于任务有返回结果的场景。
### 创建Fork/Join线程池
工作原理：
1. 创建了ForkJoinPool对象，和一个将在线程池中执行的ForkJoinTask的子类。使用了无参的类构造器创建
ForkJoinPool对象，因此将执行默认的配置。创建一个线程数等于计算机CPU数目的线程池，创建好ForkJoinPool
对象之后，那些线程也创建就绪了，在线程池中等待任务的到达，然后开始执行。
2. 由于Task类继承了RecursiveAction类，因此不返回结果。用first和last属性来表示产品列表处理的范围，
没有为每一个任务去创建不同的产品列表，仅有一份副本。
3. invokeAll()方法执行一个主任务所创建的多个子任务，这是一个同步调用，将等待子任务完成，然后继续执行。
当一个主任务等待它的子任务时，执行这个主任务的工作者线程接收另一个等待执行的任务并开始执行。
4. 调用shutdown()方法来结束执行。
### 合并任务的结果
RecursiveTask继承ForkJoinTask类，并且实现了由执行器框架提供的Future接口

如果任务需要解决的问题大于预先定义的大小，就要将这个问题拆分成多个子任务，并使用Fork/Join框架来执行
这些子任务。执行完成后，原始任务获取到由所有这些子任务产生的结果，合并这些结果，返回最终结果。
### 异步运行任务
在ForkJoinPool中执行ForkJoinTask时，可以采用同步或异步方式。当采用同步方式执行，发送任务给Fork/Join
线程池的方法直到任务执行完成后才会返回结果。而采用异步方式执行时，发送任务给执行器的方法将立即返回结果。
但是任务仍能够继续执行。

同步异步区别：
1. 采用同步方式，调用这些方法(如invokeAll()方法)时，任务被挂起，直到任务被发送到Fork/Join线程池中
运行完成。这种方式运行ForkJoinPool类采用工作窃取算法来分配一个新任务给在执行休眠任务的工作者线程。
2. 采用异步方式，当采用异步方法(比如，fork()方法)时，任务将继续执行，因此ForkJoinPool类无法使用
工作窃取算法来提升应用程序的性能。

调用fork()方法将把这个新对象发送到线程池中，如果线程池中有空闲的工作者线程或者将创建一个新的线程，
开始这行这个任务，fork()方法会立即返回，因此主任务可以继续处理文件夹里的其他内容。
一旦主任务处理完，将调用join()方法等待发送到线程池中的所有子任务执行完成。join()方法将所有的子任务
结果进行合并，这些子任务发送到线程池时带有自己的结果列表，然后通过compute()方法返回这个列表作为
主任务的返回值。
### 在任务中抛出异常
不能在ForkJoinTask类的compute()方法中抛出任何checkedException，因为这个方法的实现没有包含任何throws
声明。

抛出运行时异常，但是程序不会停止。isCompletedAbnormally()和getException()可以获得抛出的异常。

当任务抛出异常时，会影响它的父任务，以及父任务的父任务，都是以异常结束的。
### 取消任务
ForkJoinPool类中执行ForkJoinTask对象时，在任务开始执行前都可以取消它。
ForkJoinTask类提供了cancel()方法来达到取消任务的目的，但是需要主要两点：
1. ForkJoinPool类不提供任何方法来取消线程池中正在运行或者等待运行的所有任务。
2. 取消任务时，不能取消已被执行的任务。

ForkJoinTask类提供了cancel()方法允许取消一个仍没有被执行的任务，如果任务已经开始执行，那么调用cancel()
方法也无法取消。这个方法接收一个名为mayInterruptIfRunning的Boolean参数。

Fork/Join框架的局限在于，ForkJoinPool线程池中的任务不允许被取消，为克服局限性，实现了TaskManager类。
TaskManager存储发送到线程池中的所有任务，可以用一个方法来取消存储的所有任务。