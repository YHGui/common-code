# JVM实战
## 深入理解Java虚拟机
粗略的看过深入理解Java虚拟机，面试的时候被“批评”在学校动手太少，希望将《深入理解Java虚拟机》中包含的代码
和优化实战尽量都自己走一遍，虽然书是用Eclipse，但由于自己几乎没用过Eclipse写代码，还是自己迁移到
IntelliJ IDEA上，顺带整理一下知识点。
### JVM内存结构
- PC寄存器，又称程序计数器（Program Counter Register，当前线程所执行的字节码的行号指示器）：分支，循环，跳转，异常处理，线程恢复都是依赖这个计数器来完成。多线程时，每个线程斗又有一个单独的程序计数器，互不影响，称之为线程私有。执行一个Java方法时计数器记录的就是正在执行的虚拟字节码指令的地址，如果是Native方法，那么计数器值为空，这个内存区域没有规定OOM。
- 虚拟机栈，就是我们平常讲的“栈”，方法执行就会创建一个栈帧，用于存储局部变量表（存放编译期可知的基本数据类型、引用类型，局部变量表所需内存在编译期间完成，当进入一个方法时，这个方法需要在桢中分配多大的局部变量空间完全时确定的，在方法运行期间不会改变局部变量表的大小），操作数栈，动态链接，方法出口等信息
- 本地方法栈：虚拟机使用到的Native方法
- 堆：存放对象实例，线程共享。Java堆中可能划分多个线程私有的分配缓冲区，无论如何划分，与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分是为了更好的回收内存。
- 方法区：线程共享，用于存储已被虚拟机加载的类信息量，常量，静态变量，即时编译后的代码等数据。运行时常量池也是方法区的一部分，并且Java虚拟机规范并没有对常量池有要求，运行期间也可以讲新的常量放入池中。
- 对象内存布局

![Alt text](https://github.com/YHGui/common-code/blob/a6592ca294b8e9c4a4faab497988aa7cd26aefdc/src/com/katsura/jvm/images/Java-array-object.png)

- 方法区
    1. JDK7永久代
    2. JDK8 metaspace
- OutOfMemory异常
    1. -Xms 堆最小值 -Xmx 堆最大值
    2. -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机出现内存溢出异常时Dump出当前的内存堆转储快照。
    3. -Xss128k设置栈大小
    4. -XX:PermSize和-XX:MaxPermSize设置永久代的大小和最大值
    5. -XX:MaxDirectMemorySize 本机直接内存
    6. -XX:+/-UseTLAB设定是否使用TLAB
### 垃圾收集器和内存分配策略
1. 哪些内存需要回收？
- 堆和方法区
  1. 堆中的对象(新生代)->引用计数法和可达性分析算法
  2. 方法区(永久代)废弃常量和无用的类
     1. 废弃常量：没有其他对象引用
     2. 无用类：实例都被回收 + ClassLoader已经被回收 + 无法在任何地方通过反射访问该
     类的方法 
2. 什么时候回收？
   1. Minor GC：新生代GC，一般来说，对象直接在新生代的Eden space，若空间不足则Minor GC；
   2. Full GC：老年代GC，速度慢Minor GC十倍以上；
3. 如何回收？
- 枚举根节点->停顿在某个时间点找到不变化的引用关系->安全点->安全区域
- 垃圾回收算法
  1. 标记-清除(Mark-Sweep)算法
  2. 标记-整理(Mark-Compact)算法
  3. 复制(Copying)算法：Eden space, from survivor, to survivor
  4. 分代(Generation)收集算法
- 垃圾收集器
  1. Young Generation: 
   - Serial收集器, 
   - ParNew收集器,
   - Parallel Scavenge收集器
  2. Old Generation: 
   - Serial Old收集器, 
   - Parallel Old收集器,
   - CMS(Concurrent Mark Sweep)收集器：初始标记->并发标记->重新标记->并发清除，
   难以解决“浮动垃圾”以及有空间碎片
   - G1(Garbage First)收集器：初始标记->并发标记->最终标记->筛选回收，分代收集，空间整合，可预测的停顿。
   将整个Java堆分成若干个Region，根据每个Region的“价值大小”维护一个优先级列表，然后回收价值最大Region。
4. JVM 参数
   1. -XX:PretenureSizeThreshold：大于这个参数的对象直接进入老年代
   2. 长期存活对象进入老年代
   3. -Xmn新生代大小
   4. -XX:SurvivorRatio：Eden和survivor大小比值
   5. 动态对象年龄判定，若survivor空间相同年龄所有对象总和大于survivor一半，那么大于这个年龄的对象直接进入老年代。
   6. -XX:-HandlePromotionFailure担保失败
### 类文件结构
1. Class文件组成：一组以8字节为基础单位的二进制流，各个数据项目间没有分隔符。若数据项空间大于8字节，
则变成若干个8位字节进行存储。
2. Magic Number：确定文件是否能被虚拟机接受，是否是class文件(OxCAFEBABE)
3. 版本号：次版本号+主版本号
4. 很多内容感觉都不重要，或者可以查，此处我略过了。
### 类加载的过程
1. 加载
   1. 通过一个类的全限定名来获取定义此类的二进制字节流；
   - 从zip包中读取，最终成为日后JAR EAR WAR格式的基础
   - 从网络中读取
   - 运行时计算生成，动态代理技术
   - 有其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类
   - 从数据库中读取
   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
   3. 在内存中生成一个代表这个类的的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
2. 连接
   1. 验证：为了确保Class文件的字节流包含的信息符合当前虚拟机的要求。
      1. 文件格式验证：验证字节流是否符合Class文件格式的规范
      2. 元数据验证：语义分析，保证其描述信息符合语言规范
      3. 字节码验证
      4. 符号引用验证
   2. 准备：为类变量分配内存并设置类变量初始值
   - 这时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，初始值“通常情况”下是数据类型的零值，而非赋值的初始值，
   比如，所有的int类型都初始值为0，即使有初始赋值。初始赋值是在初始化期间赋值；但是如果是constant，也就是final修饰的话，直接赋值。
   3. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程
   - 符号引用：一组表示引用目标的符号
   - 直接引用：直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄，有直接引用，那么引用的目标必定已经在内存中存在。
      1. 类或接口的解析：如果不是数组类型，则将全限定名传递给其类加载器去价值这个类；
      2. 字段解析：先解析出类或接口，如果解析出的类直接包含目标字段描述符，对应其直接引用，否则递归类或接口寻找直接引用
      3. 类方法解析：先解析出类或接口，如果能直接找到相应的的简单字段描述符，对应直接引用，解析结束，否则递归寻找
      4. 接口方法解析：先解析出父接口，然后一步步递归寻找对应方法，找不到则抛出异常。
3. 初始化：类加载的最后一步，开始执行类中定义的代码(字节码)，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。
   初始化阶段是执行类构造器<clinit>()方法的过程，但是与实例构造器<init>()方法不同。
   - <clinit>()方法与类的构造函数不同，不需要显示的调用父类构造器，虚拟机会保证父类的<clinit>()方法在之前已经执行完毕。
   第一个被执行的是Object的<clinit>()
4. 类加载器：通过一个类的全限定名来获取定义此类的二进制字节流，实现类加载中的加载动作，但是作用不限于此。一个加载器确定一个类的命名
空间。判断一个类是否相同需要在同一类加载器的前提下才有意义。
   - 启动类加载器<-扩展类加载器<-应用程序类加载器<-自定义类加载器
   - 双亲委派模型：当需要加载一个类时先使用父类加载器（其实这个地方不是很准确，父子关系是通过复合来实现的），
     若失败了，再使用当前的加载器。如果自己写一个 Object 类，编译可通过但是由于双亲委派，它永远都不会被加载。
### 虚拟机字节码执行引擎  
1. 物理机执行引擎：直接建立在处理器、硬件、指令集和操作系统层面的。
2. 虚拟机执行引擎：自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
### 早期(编译器)优化
1. Javac编译器
- 编译过程分为三个过程：
  1. 解析与填充符号表的注解处理过程
        1. 解析：parseFiles()方法：词法分析和语法分析
            1. 词法分析：将源代码的字符流转变为标记(Token)集合，单个字符是程序编写过程的最小元素，而Token则是编译过程的最小元素，
            关键字、变量名、字面量、运算符都可以成为Token。Javac源码中，词法分析由com.sun.tools.javac.parser.Scanner类实现。
            2. 语法分析：根据Token序列构造抽象语法树的过程，抽象语法树(AST)是一种用来描述语法结构的树形表示方式，语法树的每一个
            节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。
        2. 填充符号表：enterTree()方法所做的事情。符号表是由一组符号地址和符号信息构成的表格。符合表中所登记的信息在编译的不同
        阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码。在
        目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。
        3. 注解处理器：编译器的插件，可以读取、修改、添加抽象语法树中的任意元素。每对语法树做修改，编译器将重新解析以及填充符号表，
        直到注解处理器不再修改为止，每次循环称为一个Round。
        4. 语义分析和字节码生成：语法树表示源程序的抽象，但无法保证源程序是符合逻辑的(判断合乎逻辑需要限定语言和具体的上下文环境)。
            1. 标注检查：检查内容包括诸如变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配。有一个重要的步骤是常量折叠。
            2. 数据及控制流分析：进一步验证，诸如：程序局部变量使用前是否有赋值、方法的每条路径是否都有返回值、是否checked异常都
            被正确处理。
            3. 解语法糖：添加的某种语法对语言的功能并没有影响，但是更方便程序员使用(增加程序的可读性，从而减少程序员代码出错机会)。
            在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。
            4.字节码生成：Javac编译最后一个阶段，将前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行少量代码添加和转换
            工作。
  2. 插入式注解处理器的注解处理过程
  3. 分析与字节码生成过程
2. Java语法糖
    1. 泛型与类型擦除：(JDK1.5)本质是参数化类型：所操作的数据类型被指定为一个参数，这种参数类型可以在类、接口、方法中创建。
    Java的泛型仅在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制转换代码。
    泛型所谓的擦除，仅仅是对方法的Code属性的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得
    参数化类型的根本依据。
    2. 自动装箱、拆箱与遍历循环
    3. 条件编译：Java编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此
    各个文件之间能够互相提供符号信息，因此无需使用预处理器。
    Java中的if语句中条件为常量，编译之后，只剩下条件为真的代码
###  Java内存模型与线程
