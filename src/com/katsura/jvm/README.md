# JVM实战
## 深入理解Java虚拟机
粗略的看过深入理解Java虚拟机，面试的时候被“批评”在学校动手太少，希望将《深入理解Java虚拟机》中包含的代码
和优化实战尽量都自己走一遍，虽然书是用Eclipse，但由于自己几乎没用过Eclipse写代码，还是自己迁移到
IntelliJ IDEA上，顺带整理一下知识点。
### JVM内存结构
- PC寄存器，又称程序计数器（Program Counter Register，当前线程所执行的字节码的行号指示器）：分支，循环，跳转，异常处理，线程恢复都是依赖这个计数器来完成。多线程时，每个线程都有一个单独的程序计数器，互不影响，称之为线程私有。执行一个Java方法时计数器记录的就是正在执行的虚拟字节码指令的地址，如果是Native方法，那么计数器值为空，这个内存区域没有规定OOM。
- 虚拟机栈，就是我们平常讲的“栈”，方法执行就会创建一个栈帧，用于存储局部变量表（存放编译期可知的基本数据类型、引用类型，局部变量表所需内存在编译期间完成，当进入一个方法时，这个方法需要在桢中分配多大的局部变量空间完全时确定的，在方法运行期间不会改变局部变量表的大小），操作数栈，动态链接，方法出口等信息
- 本地方法栈：虚拟机使用到的Native方法
- 堆：存放对象实例，线程共享。Java堆中可能划分多个线程私有的分配缓冲区，无论如何划分，与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分是为了更好的回收内存。
- 方法区：线程共享，用于存储已被虚拟机加载的类信息量，常量，静态变量，即时编译后的代码等数据。运行时常量池也是方法区的一部分，存放编译期生成的各种字面量和符号引用，并且Java虚拟机规范并没有对常量池有要求，运行期间也可以将新的常量放入池,对于运行时产生的一个变量如果频繁复制并且不可变，可以通过intern()将其放到常量池，算是一个小的优化区。
- 对象内存布局

![Alt text](https://raw.githubusercontent.com/YHGui/common-code/a6592ca294b8e9c4a4faab497988aa7cd26aefdc/src/com/katsura/jvm/imagesava-array-object.png)

- 直接内存
    1. JDK7永久代
    2. JDK8 metaspace
对象创建的过程：new指令，首先JVM对符号引用进行解析，如果找不到符号引用，那么类没有被加载，JVM便会进行类加载，符号引用解析完毕，JVM会为对象在堆中分配内存，Java对象包括三部分，对象头，包括Mark Word和class pointer，虚拟机通过这个指针来确定它是哪个类的实例，如果是数组对象，则还包含数组长度，对象中还包含的就是instance data，其中要注意的是，实例字段包括自身定义的和从父类继承下来的（即使父类的实例字段被子类覆盖或者被private修饰，都照样为其分配内存）最后就是对齐字段，分配完堆内存之后，JVM会将该内存进行零值初始化，这也就是为什么属性字段不需要初始化也能用的原因，而局部变量必须进行初始化才能用，当然还会调用init方法，根据程序员意愿进行初始化，最后会调用构造函数，当然调用顺序会一直追溯到Object对象。
- 内存泄漏：GC Roots引用一直存在，无法自动回收，这种情况应该查看引用链，准确定位泄漏代码的位置。
- 内存溢出：内存中的对象必须存活，即虚拟机参数过小，这种情况堆参数和检查代码中对象的存在时间是否过长。
- OutOfMemory异常
    1. -Xms 堆最小值 -Xmx 堆最大值
    2. -XX:+HeapDumpOnOutOfMemoryError 可以让虚拟机出现内存溢出异常时Dump出当前的内存堆转储快照。
    3. -Xss128k设置栈大小
    4. -XX:PermSize和-XX:MaxPermSize设置永久代的大小和最大值
    5. -XX:MaxDirectMemorySize 本机直接内存
    6. -XX:+/-UseTLAB设定是否使用TLAB
### 垃圾收集器和内存分配策略
1. 哪些内存需要回收？
- 堆和方法区
  1. 堆中的对象(新生代)->引用计数法（有对象引用加1，引用实效则减1）和可达性分析算法（GCRoots依据引用链不可达，则该回收了，虚拟机栈中引用的对象、方法区中类静态属性引用的对象、方法区常量引用对象、本地方法栈中JNI引用对象都可以作为GCRoots对象）
  - 引用
     1. 强引用，垃圾收集器不会回收，类似Object obj = new Object()
     2. 软引用，有用但非必需
     3. 弱引用，生存到下一次GC之前
     4. 虚引用，目的是在这个对象被GC时收到一个系统通知
  2. 方法区(永久代)废弃常量和无用的类
     1. 废弃常量：没有其他对象引用
     2. 无用类：实例都被回收 + ClassLoader已经被回收 + 无法在任何地方通过反射访问该类的方法 
GC分类：
  - partial gc：并不收集整个gc堆的模式
    - Yonung gc：只收集young gen的gc
    - old gc：之收集old gen的gc。只有cms的concurrent collection是这个模式
    - mixed gc：收集整个young gen以及部分old gen的gc，只有g1有这个模式
  - full gc：收集整个堆，包括young gen old gen，perm gen。
  - 最简单的分代式gc：
    - young gc：young gen中的eden区分配满的时候触发，部分存活对象会晋升到old gen
    - full gc：当准备要触发一次young gc时，如果发现统计数据说之前的young gc的晋升大小比目前old gen剩余的空间大，则不会出发young gc而转为触发full gc，如果有perm gen，在perm gen分配空间但已经没有足够的空间时，也要触发一次full gc
2. 什么时候回收？
   1. Minor GC：新生代GC，一般来说，对象直接在新生代的Eden space，若空间不足则Minor GC；
   2. Full GC：老年代GC，速度慢Minor GC十倍以上；
3. 如何回收？
- 枚举根节点->停顿在某个时间点找到不变化的引用关系->安全点->安全区域
- 垃圾回收算法
  1. 标记-清除(Mark-Sweep)算法：效率不高，内存碎片产生。
  2. 标记-整理(Mark-Compact)算法：标记后，存活的对象移动到一边，适合老年代。
  3. 复制(Copying)算法：内存使用率降低，换成Eden space, from survivor, to survivor，适合新生代。
  4. 分代(Generation)收集算法
- 垃圾收集器
  1. Young Generation: 
   - Serial收集器，单线程，stop the world
   - ParNew收集器, 多线程版Serial
   - Parallel Scavenge收集器
  2. Old Generation: 
   - Serial Old收集器, 
   - Parallel Old收集器,
   - CMS(Concurrent Mark Sweep)收集器：初始标记->并发标记->重新标记->并发清除，希望获取最短系统停顿时间，对cpu资源敏感，难以解决“浮动垃圾”以及有空间碎片
   - G1(Garbage First)收集器：初始标记->并发标记->最终标记->筛选回收，分代收集，空间整合，可预测的停顿。将整个Java堆分成若干个Region，根据每个Region的“价值大小”维护一个优先级列表，然后回收价值最大Region。
  3. GC日志
   - Full：表示GC发生了stop the world X -> X表示回收前后内存使用容量，再往后就是GC时间
4. JVM 参数
   1. -XX:PretenureSizeThreshold：大于这个参数的对象直接进入老年代
   2. 长期存活对象进入老年代
   3. -Xmn新生代大小
   4. -XX:SurvivorRatio：Eden和survivor大小比值
   5. 动态对象年龄判定，若survivor空间相同年龄所有对象总和大于survivor一半，那么大于这个年龄的对象直接进入老年代。
   6. -XX:-HandlePromotionFailure担保失败
5. 对象内存分配策略
   1. 对象优先分配在新生代Eden区
   2. 大对象直接进入老年代
   3. 长期存活对象进入老年代
   4. 动态对象年龄判定
   5. 空间分配担保
### 虚拟机性能监视工具
1. jps：虚拟机进程状况工具
2. jstat：虚拟机统计信息监视工具
3. jinfo：Java配置信息工具
4. jmap：Java内存映像工具
5. jhat：虚拟机堆转储快照 分析工具
6. jstack：Java堆栈跟踪工具
7. JConsole：Java监视与管理控制台
### 类文件结构（类文件数据结构太过繁琐，希望真正研究字节码的时候对应着查询阅读，后续的字节码指令类似于汇编指令）
1. Class文件组成：一组以8字节为基础单位的二进制流，各个数据项目间没有分隔符。若数据项空间大于8字节，
则变成若干个8位字节进行存储，数据结构只有无符号数和表。任何一个class文件都对应着唯一一个类或接口的定义信息，反过来说，类或接口不一定都定义在文件里，也可以直接通过类加载器直接生成。
2. Magic Number：确定文件是否能被虚拟机接受，是否是class文件(OxCAFEBABE)
3. 版本号：次版本号+主版本号
4. 常量池：字面量和符号引用（类和接口全限定名，字段的名称和描述符，方法的名称和描述符）
5. 访问标志：识别类和接口层次的访问信息
6. 类索引，父类索引与接口索引的集合
7. 字段表集合
8. 方法表集合
9. 属性表集合
### 类加载的过程
1. 加载
   1. 通过一个类的全限定名来获取定义此类的二进制字节流；
   - 从zip包中读取，最终成为日后JAR EAR WAR格式的基础
   - 从网络中读取
   - 运行时计算生成，动态代理技术
   - 有其他文件生成，典型场景是JSP应用，即由JSP文件生成对应的Class类
   - 从数据库中读取
   2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；
   3. 在内存中生成一个代表这个类的的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
2. 连接
   1. 验证：为了确保Class文件的字节流包含的信息符合当前虚拟机的要求。
      1. 文件格式验证：验证字节流是否符合Class文件格式的规范
      2. 元数据验证：语义分析，保证其描述信息符合语言规范
      3. 字节码验证
      4. 符号引用验证
   2. 准备：为类变量分配内存并设置类变量初始值
   - 这时候进行内存分配的仅包括类变量(被static修饰的变量)，不包括实例变量，初始值“通常情况”下是数据类型的零值，而非赋值的初始值，
   比如，所有的int类型都初始值为0，即使有初始赋值。初始赋值是在初始化期间赋值；但是如果是constant，也就是final修饰的话，直接赋值。
   3. 解析：虚拟机将常量池内的符号引用替换为直接引用的过程
   - 符号引用：一组表示引用目标的符号
   - 直接引用：直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄，有直接引用，那么引用的目标必定已经在内存中存在。
      1. 类或接口的解析：如果不是数组类型，则将全限定名传递给其类加载器去加载这个类，如果是数组类型，描述符应该为数组描述符，对象单独加载，然后生成数组维度和元素的数组对象。
      2. 字段解析：先解析出类或接口，如果解析出的类直接包含目标字段描述符，对应其直接引用，否则递归类或接口寻找直接引用
      3. 类方法解析：先解析出类或接口，如果能直接找到相应的的简单字段描述符，对应直接引用，解析结束，否则递归寻找
      4. 接口方法解析：先解析出父接口，然后一步步递归寻找对应方法，找不到则抛出异常。
3. 初始化：类加载的最后一步，开始执行类中定义的代码(字节码)，根据程序员通过程序制定的主观计划去初始化类变量和其他资源。初始化阶段是执行类构造器<clinit>()方法的过程，但是与实例构造器<init>()方法不同。
   - <clinit>()方法与类的构造函数不同，不需要显示的调用父类构造器，虚拟机会保证父类的<clinit>()方法在之前已经执行完毕。第一个被执行的是Object的<clinit>()
   - 必须对类进行初始化：1. new，getstatic，putstatic，invokestatic4条字节码指令时 2. 反射调用时 3. 若父类未进行初始化，先触发父类初始化 4.虚拟机启动初始化主类（main方法在其中）5. 动态语言支持时，java.lang.invoke.MethodHandler实例最后解析的结果为REF_getStatic REF_putStatic REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化。 
4. 类加载器：通过一个类的全限定名来获取定义此类的二进制字节流，实现类加载中的加载动作，但是作用不限于此。一个加载器确定一个类的命名空间。判断一个类是否相同需要在同一类加载器的前提下才有意义。
   - 启动类加载器<-扩展类加载器<-应用程序类加载器<-自定义类加载器
   - 双亲委派模型：当需要加载一个类时先使用父类加载器（其实这个地方不是很准确，父子关系是通过复合来实现的），若失败了，再使用当前的加载器。如果自己写一个 Object 类，编译可通过但是由于双亲委派，它永远都不会被加载。
### 虚拟机字节码执行引擎  
1. 物理机执行引擎：直接建立在处理器、硬件、指令集和操作系统层面的。
2. 虚拟机执行引擎：自己实现的，因此可以自行制定指令集和执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。
3. 栈帧：存储局部变量表，操作数栈，动态连接和方法返回地址等信息
  - 局部变量表，其中类变量有两次赋初始值的过程，一次在准备过程，一次在初始化阶段，但局部变量不一样，没有初始值会报错，不能使用。如果当前字节码PC计数器超出了某个变量的作用域，那么这个变量对应的slot就可以交给其他变量使用。
  - 操作数栈：动态连接，每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
  1.静态解析：在类加载或者第一次使用的时候就转化为直接引用
  2. 动态连接：运行期间转为直接引用
  - 方法返回地址：执行引擎遇到任意一个方法返回的字节码指令时会退出，另外一种方式是方法执行过程中遇到异常
4.方法调用
- 解析：调用目标在程序代码写好、编译器进行编译时就必须确定下来。只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段唯一确定调用版本，如静态方法，私有方法，实例构造器，父类方法等调用。
- 静态分派：依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型应用：方法重载，静态分派发生在编译阶段，重载时通过参数的静态类型而不是实际类型作为判定的依据的，确定使用哪个重载版本是在编译阶段就确定的，实际类型需要在运行期才知道。
- 动态分派：运行期间确定接收者的实际类型，解析就能将符号引用解析道不同的直接引用上，这就是Java语言方法重写的本质。
- 静态多分派，动态多分派。
### 早期(编译器)优化
1. Javac编译器
- 编译过程分为三个过程：
  1. 解析与填充符号表的注解处理过程
        1. 解析：parseFiles()方法：词法分析和语法分析
            1. 词法分析：将源代码的字符流转变为标记(Token)集合，单个字符是程序编写过程的最小元素，而Token则是编译过程的最小元素，关键字、变量名、字面量、运算符都可以成为Token。Javac源码中，词法分析由com.sun.tools.javac.parser.Scanner类实现。
            2. 语法分析：根据Token序列构造抽象语法树的过程，抽象语法树(AST)是一种用来描述语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。
        2. 填充符号表：enterTree()方法所做的事情。符号表是由一组符号地址和符号信息构成的表格。符合表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查(如检查一个名字的使用和原先的说明是否一致)和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。
        3. 注解处理器：编译器的插件，可以读取、修改、添加抽象语法树中的任意元素。每对语法树做修改，编译器将重新解析以及填充符号表，直到注解处理器不再修改为止，每次循环称为一个Round。
        4. 语义分析和字节码生成：语法树表示源程序的抽象，但无法保证源程序是符合逻辑的(判断合乎逻辑需要限定语言和具体的上下文环境)。
            1. 标注检查：检查内容包括诸如变量使用前是否已被声明，变量与赋值之间的数据类型是否能够匹配。有一个重要的步骤是常量折叠。
            2. 数据及控制流分析：进一步验证，诸如：程序局部变量使用前是否有赋值、方法的每条路径是否都有返回值、是否checked异常都
            被正确处理。
            3. 解语法糖：添加的某种语法对语言的功能并没有影响，但是更方便程序员使用(增加程序的可读性，从而减少程序员代码出错机会)。
            在编译阶段还原回简单的基础语法结构，这个过程称为解语法糖。
            4.字节码生成：Javac编译最后一个阶段，将前面各个步骤所生成的信息转化成字节码写到磁盘中，编译器还进行少量代码添加和转换
            工作。
  2. 插入式注解处理器的注解处理过程
  3. 分析与字节码生成过程
2. Java语法糖
    1. 泛型与类型擦除：(JDK1.5)本质是参数化类型：所操作的数据类型被指定为一个参数，这种参数类型可以在类、接口、方法中创建。Java的泛型仅在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制转换代码。泛型所谓的擦除，仅仅是对方法的Code属性的字节码进行擦除，实际上元数据中还是保留了泛型信息，这也是我们能通过反射手段取得参数化类型的根本依据。
    2. 自动装箱、拆箱与遍历循环
    3. 条件编译：Java编译器并非一个个地编译Java文件，而是将所有编译单元的语法树顶级节点输入到待处理列表后再进行编译，因此
    各个文件之间能够互相提供符号信息，因此无需使用预处理器。
    Java中的if语句中条件为常量，编译之后，只剩下条件为真的代码
###  Java内存模型与线程
1. volatile：
    - 保证此变量对所有线程的可见性
    - 禁止指令重排序优化
2. 线程安全的实现方法：
    1. 互斥同步：临界区，互斥量，信号量
    2. synchronized，编译后会在同步块前后分别形成monitorenter和monitorexit两个字节码指令，这两个字节码都需要一个reference类型参数来指明要锁定的对象和解锁的对象。synchronized同步块对同一条线程来说是可重入的，不会出现把自己锁死的问题，同步块在已进入的线程执行完之前，会阻塞后面的其他线程进入，synchronized比较重，阻塞或者唤醒线程耗费时间很长。重入锁是api层面的互斥锁，另一个表现为原声语法层面的互斥锁，ReentrantLock加入了高级功能：
      - 等待可中断：如果持有锁时间太长，等待的线程可以放弃，改去处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
      - 公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则不保证，任何一个线程都有机会，synchronized就是非公平锁，ReentrantLock默认时非公平，但可以设置成公平锁
      - 锁可以绑定多个条件：一个ReentrantLock对象可以绑定多个Condition对象，而synchronized中，要和多个条件关联时，需要额外添加锁， ReentrantLock只需要多次调用newCondition()方法即可
    3. 非阻塞同步：先操作，如果没有其他线程竞争，就成功，产生冲突，再采取补偿措施，乐观的操作。
    4. 无同步方案：可重入代码，即使被中断返回后仍不会出现错误；线程本地存储。
    5. 自旋锁和自适应自旋：如果锁定状态持续的时间很短，而挂起线程和恢复线程的资源消耗更大，这样不值当，因此让请求锁的的线程稍等，看之前拿到锁的线程是否执行一段时间就释放了，因此每次只需要去try一下，当然try也是需要耗费cpu资源的，当然不能无休止的自旋，可以设置自旋次数，1.6引入自适应自旋，依据之前的自旋时间和锁的拥有者状态来给定一个自旋等待时机，自适应学习的过程会使虚拟机越来越准确。
    6. 锁粗化：防止频繁的加锁解锁导致性能损耗
    7. 轻量级锁：在没有多线程竞争的情况下，减少传统的重量级锁使用操作系统互斥量产生的性能损耗。依据对象的内存布局来保证多线程安全，进入同步块时，如果此同步对象没有被锁定，虚拟机首先在当前栈帧建立一个锁记录，用于存储锁对象目前的Mark Word的copy，然后虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针，动作更新成功，这个线程就拥有了该对象的锁，标志位变为处于轻量级锁定的状态，如果更新失败，检查Mark Word是否指向当前线程的栈帧，如果只说明当前线程已经拥有了这个对象的锁，直接进入同步块继续执行，否则说明锁对象被其他线程抢占了，如果产生竞争，轻量级锁膨胀为重量级锁。
    8. 偏向锁：消除同步，锁会偏向于第一个获得它的线程，下次再进入优先获取锁，若有竞争，则宣告结束。
    9. 锁消除：可能某段时间共享数据并不会出现竞争状态，做逃逸分析时，堆上所有的数据不会被其他线程访问，在对String操作的时候，StringBuffer的大部分操作都加入了synchronized，而实际上拼接字符串的操作变量不会逃逸到拼接代码段的外部，因此编译器在优化的时候会将锁消除。
    10.CAS操作：在使用上，通常会记录下某块内存中的旧值，通过对旧值进行一系列的操作后得到新值，然后通过CAS操作将新值与旧值进行交换。如果这块内存的值在这期间内没被修改过，则旧值会与内存中的数据相同，这时CAS操作将会成功执行 使内存中的数据变为新值。如果内存中的值在这期间内被修改过，则一般[2]来说旧值会与内存中的数据不同，这时CAS操作将会失败，新值将不会被写入内存。
