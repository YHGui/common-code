# Thread
### 并发&并行
并发：一系列任务同时运行，如果电脑多个处理器，这个同时性是真正意义上的并发，但是电脑只有一个单核处理器，这个同时性不是真正意义的并发。
就我认为：并发是单个处理器中一个进程中多个线程不同时占用CPU，由于切换CPU占用时间间隔非常短，可以看成同时。而并行是在包含多个处理器的
情况下，每个处理器处理并发的执行任务。
### 线程属性
1. 线程的六种状态( Status)
- new
- runnable
- blocked
- waiting
- time waiting
- terminated
2. 线程ID
3. 线程名称：name
### 中断机制
所有的非守护线程运行结束时，或者其中一个线程调用***System.exit***()方法时，所有线程都将结束，这个Java程序才允许结束。

中断机制要求线程检查它是否被中断了，然后决定是不是响应这个中断请求，线程允许忽略中断请求并且继续执行。

Thread类有一个表明线程被中断与否的属性，它存放的是布尔值。线程的interrupt()方法被调用时，这个属性就
被设置为true。isInterrupted()方法只是返回这个属性的值。

interrupted()也能用来检查当前执行的线程是否被中断，它和isInterrupted()的区别是，interrupted()能够
设置interrupted属性为false，它是一个静态方法，推荐使用isInterrupted().
### 线程的休眠和恢复
sleep()方法接受整型数值作为参数，表明线程挂起执行的毫秒数，当线程休眠的时间结束了，JVM会分给他CPU时间，
线程将继续执行它的指令。

如果休眠中线程被中断，该方法就会立即抛出InterruptedException异常，而不需要等待到线程休眠时间结束。
###等待线程的终止
某些情形下，我们必须等待线程终止。例如我们的程序在执行其他任务时，必须初始化一些必须的资源，因此需要等
线程终止后再执行其他任务。

为了达到这个目的，使用join()方法。当一个线程对象的join方法被调用时，调用它的线程将被挂起，直到这个
线程对象完成它的任务。

join()方法如果有参数，那么即使被调用线程没有执行完，但是时间已经到了，也将返回，即资源回到本线程。
### 守护线程
守护线程：优先级低，通常说，当同一个应用程序里没有其他线程运行时，守护线程才运行，也就是说守护线程运行
结束，JVM也就结束了这个程序。

守护线程被用来作为同一程序中普通线程(用户线程)的服务提供者，通常是无限循环，以等待服务请求者或者执行
线程的任务。一个典型的守护线程是Java的垃圾回收器。

setDaemon()只能在start()方法被调用之前设置。一旦线程开始运行，将不能再修改守护状态。

isDaemon()方法被用来检查一个线程是不是守护线程，true则表示为守护线程。
### 不可控异常的处理
- 非运行时异常(Checked Exception) 必须throws或者捕获
- 运行时异常(Unchecked Exception) 不必在方法声明中指定，也不需要在方法体中捕获。
- run方法不支持throws语句，因此必须捕获异常并处理
### 线程局部变量的使用
如果创建的对象是实现了Runnable接口的类的实例，用它作为传入参数创建多个线程对象并启动这些线程，那么所有的
线程将享有相同的属性。也就是说，如果在一个线程中改变一个属性，所有线程都会被这个改变影响。

某种情况下，这个对象属性不需要被所有属性共享，就需要*线程局部变量(Thread-Local Variable)*，性能较好。

线程局部变量为每个线程存储了各自的属性值，并提供给每个线程使用。可以用get()方法获取这个值，并用set()方法
设置这个值。如果线程第一次访问线程局部变量，线程局部变量可能还没有为它存储值，这时候initialValue()
方法就会被调用。

线程局部变量也提供了remove()方法，用来为访问这个变量的线程删除已经存储的值。
Java并发API包含了InheritableThreadLocal类，如果一个线程是从其他某个线程创建的，这个类将提供继承
的值。如果一个线程A在线程局部变量已有值，当他创建其他某个线程B时，线程B的线程局部变量跟线程A是一样的。
可以附带childValue()方法，这个方法用来初始化子线程在局部变量中的值。使用父线程在线程局部变量中的值
作为传入参数。
### 线程的分组
Java并发API能够把线程分组，那么一个组的线程可以分成一个单一的单元，对组内线程进行访问并操作它们。
同组的线程只需要一个单一的调用。Java提供ThreadGroup表示一组线程，既可以包含线程对象，也可以包含
线程组对象，是一个树形结构。
### 线程组中的不可控异常处理
建立一个方法来捕获线程组中的任何线程对象抛出的非捕获异常

当一个线程对象抛出了异常，其余的线程对象都被中断。
当线程抛出非捕获异常时，JVM将为这个异常寻找3种可能的处理器：
- 首先，寻找抛出这个异常线程的非捕获异常处理器；
- 如果不存在，JVM继续查找这个线程所在线程组的非捕获异常处理器；
- 如果也不存在，JVM将寻找默认的非捕获异常处理器。
### 使用工厂类创建线程
工厂模式是一个创建者模式，使用一个类为其他的一个或者多个类创建对象。当我们要为这些类创建对象时，不再使用
new构造器，而使用工厂类。好处在于：
- 容易修改类，或者改变创建对象的方式；
- 容易为有限资源限制创建对象的数目，例如可以限制一个类型的对象不多于n个；
- 容易为创建的对象生成统计数据。
Java提供了ThreadFactory接口，实现了线程对象工厂