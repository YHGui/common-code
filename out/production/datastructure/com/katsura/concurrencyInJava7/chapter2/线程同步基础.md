# 线程同步基础
### 简介
多个线程读或者写相同的数据，或者访问相同的文件或数据库连接，为防止共享资源出现的错误或数据不一致，必须
实现一些机制防止错误发生。

**临界区(Critical Section)**： 用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。

当一个线程试图访问这个临界区时，将使用一种同步机制来查看是不是已经有其他线程进入临界区。如果没有，则进入；
如果已经有线程进入了临界区，他就被同步机制挂起，直到进入的线程离开这个临界区。如果在等待进入临界区的线程
不止一个，JVM会选择其中一个，其余的将继续等待。
### synchronized实现同步方法
**需要理解的是：synchronized保护的是对象，而不是代码**

一个对象若用**synchronized**关键字声明，那么只有一个执行线程被允许访问它。其他线程试图访问这个对象的其他
方法，它将被挂起，直到第一个线程执行完正在运行的方法。

每一个用**synchronized**关键字声明的*方法*都是临界区。Java中，同一个对象的临界区，在同一时间只有一个允许
被访问。

静态方法则有不同的行为。用**synchronized**关键字声明的静态方法，同时只能够被一个执行线程访问，但是其他线程可
以访问这个对象的非静态方法。

因此需谨慎：如果两个线程同时访问一个对象的两个不同的**synchronized**方法，一个静态，一个非静态。如果两个方法都改
变了相同的数据，将会出现数据不一样的错误。

如果两个线程访问的是同一个类的不同对象，那么两个线程都不会被阻塞。

**synchronized**会降低应用程序的性能，只能在并发情景中需要修改共享数据的方法上使用它。

可以递归调用synchronized声明的方法。当线程访问一个对象的同步方法时，它还可以调用这个对象的其他同步方法，
也包含正在执行的方法，不必再次去获取这个方法的访问权。

使用**synchronized**保护代码块，方法的其余部分保持在**synchronized**代码块之外，以获取更好的性能。

用this关键字来引用正在执行的方法所属的对象。synchronized(this){//code}
### 使用非依赖属性实现同步
用synchronized关键字保护代码块时，我们使用对象作为它的传入参数。通常情况下，使用this关键字引用执行方法所属的对象，也可以使用
其他的对象对其进行引用，一般来说，这些对象也就是为了这个目的而建的。
JVM保证同一时间只有一个线程能够访问这个对象的代码保护块(**注意我们一直谈论的是对象，不是类**)。

用不同的对象来控制对属性的访问，同一时间只有一个线程能修改这个属性，但是允许同时运行两个线程，修改不同
的属性。
### 在同步代码中使用条件
生产者-消费者(Producer-Consumer)问题：一个或多个数据生产者把数据存入数据缓冲区，一个或者多个数据消费者将数据从缓冲区取走。
缓冲区是共享数据结构，必须使用同步机制控制对它的访问，例如使用synchronized关键字，但是包含如下限制：
- 缓冲区是满的，生产者就不能再放入数据
- 缓冲区是空的，消费者就不能读取数据

为此，Java在Object类中提供了wait(),notify(),notifyAll()方法。
线程可以在*同步代码块*中调用wait()方法，如果在同步代码块之外调用wait()方法，JVM将抛出IllegalMonitorStateException。
当一个线程调用wait()方法时，JVM将这个线程置入休眠，并且释放控制这个同步代码块的对象，
同时允许其他线程执行这个对象控制的其他同步代码块。为了唤醒这个线程，必须对这个对象控制的某个同步代码块中调用notify()或者notify()方法。

sleep()和wait()区别：
- sleep()不会导致锁行为的变化，因为和锁相关的方法都定义在Object类中，因此调用Thread.sleep()是不会影响锁的相关行为。
- Thread.sleep()和Object.wait()都会暂停当前的线程，对于CPU资源来说，不管是哪种方式暂停的线程，都表示它暂时不再需要CPU的执行时间。
OS会将执行时间分配给其它线程。区别是，调用wait后，需要别的线程执行notify()/notifyAll()才能够重新获得CPU。

notifyAll()方法并不保证哪个线程会被唤醒。
### 使用锁实现同步
同步机制二： 基于**Lock**接口机器实现类(如**ReentrantLock**)实现同步，更强大，灵活，有如下好处，
1. 支持更灵活的同步代码结构，Lock接口允许实现更复杂的临界区结构(即控制的获取和释放不出现在同一块结构中)
2. Lock接口相比synchronized提供更多的功能。如tryLock(),这个方法试图获取锁，
如果已被其他线程获取，将返回false，不会将线程置入休眠并继续往下执行代码。
使用synchronized关键字时，如果线程A试图执行一个同步代码块，
而线程B已经在执行这个同步代码块，则线程A就会被挂起知道B运行完这个同步代码块。使用tryLock()方法，
通过返回值将得知是否有其他线程正在使用这个锁保护的代码块。
3. Lock接口允许分离读和写操作，允许多个读线程和只有一个写线程
4. 相比synchronized关键字，Lock接口具有更好的性能。

如果有线程正在执行所包含的临界区代码，lock()方法将让新请求的线程休眠直到正在执行的线程执行完临界区的代码。

线程离开临界区的时候必须使用unlock()方法来释放它持有的锁，以让其他线程来访问临界区。如果临界区的时候没有
调用unlock()方法，其他线程将永久等待，从而导致死锁(DeadLock)的情景。
而如果在临界区使用了try-catch块，不要忘记将unlock()方法放入finally部分。

死锁情况： 线程A获取了锁X，线程B获取了锁Y，现在，线程A试图获取锁Y，线程B试图获取锁X，那么两个线程都将
被阻塞，而且它们等待的锁永远不会被释放。问题在于：两个线程都试图获取对方拥有的锁。

规避死锁的的原则:
1. 旨在必要的最短时间内持有锁,考虑使用同步语句块代替整个同步方法;
2. 尽量编写不在同一时刻需要持有多个锁的代码,如果不可避免,则确保持有第二个锁的时间尽量短暂;
3. 创建和使用一个大锁来代替若干小锁,并把这个锁用于互斥,而不是用作单个对象的对象级别锁
### 读写锁实现同步数据访问
最大改进之一：ReadWriteLock接口及其唯一实现类ReentrantReadWriteLock，这个类有两个锁：一个是读操作
锁，另一个是写操作锁。使用读操作锁时可以允许多个线程同时访问，但是使用写操作锁时只允许一个线程进行。
在一个线程执行写操作时，其他线程不能够执行读操作。
### 修改锁的公平性
ReentrantLock和ReentrantReadWriteLock类的构造器都含有一个布尔参数fair，默认为false，为非公平模式，
非公平指的是当很多线程在等待锁时，锁将随机选择一个来访问临界区，fair为true时，则为公平模式，公平指的是，
很多线程在等待锁时，锁将选择等待时间最长的锁。
### 在锁中使用多条件
一个锁可能关联一个或多个条件，这些条件通过***Condition***接口声明。目的是允许线程获取锁并且查看等待的某一个
条件是否满足，如果不满足就挂起直到某个线程唤醒它们。

当一个线程调用了条件对象的signal()或者signalAll()方法后，一个或者多个在该条件上挂起的线程将被唤醒，但
这并不能保证让它们挂起的条件已经满足，所以必须在while循环中调用await()，在条件成立之前不能离开这个循环。

调用await()方法进入休眠的线程可能会被中断，所以必须处理InterruptedException异常。

await(long time, TimeUnit unit), 直到发生以下情况之一以前，线程将一直处于休眠状态：
1. 其他某个线程中断当前线程
2. 其他某个线程调用了将当前线程挂起的条件signal()或signalAll()方法
3. 指定的等待时间已经过去了

awaitUninterruptibly():不可中断

awaitUntil(Date date):直到发生以下情况之一以前，线程将一直处于休眠状态
1. 其他某个线程中断当前线程
2. 其他某个线程调用了将它挂起的条件的singal()或singalAll()方法
3. 指定的最后期限到了
